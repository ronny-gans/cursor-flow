#!/usr/bin/env python3
"""
Replace cursor in video using logged coordinates.
Uses the JSON file generated by record_with_cursor.py for precise cursor replacement.

Usage:
    python replace_cursor.py -i recording.mp4 -o output.mp4
    
The script automatically looks for recording.json alongside the input video.
"""

import cv2
import numpy as np
import json
import argparse
import subprocess
import tempfile
import os
from pathlib import Path


def create_circle_cursor(size=32, color=(0, 255, 255), border_color=(0, 0, 0), border_width=2):
    """Create a circle cursor with transparency."""
    cursor = np.zeros((size, size, 4), dtype=np.uint8)
    center = size // 2
    radius = size // 2 - border_width
    
    # Draw filled circle
    cv2.circle(cursor, (center, center), radius, (*color, 255), -1)
    
    # Draw border
    cv2.circle(cursor, (center, center), radius, (*border_color, 255), border_width)
    
    return cursor


def create_fancy_cursor(size=48):
    """Create a beautiful modern cursor with perfectly smooth edges."""
    # Very high scale for perfect antialiasing
    scale = 16
    large_size = size * scale
    
    # Create cursor with float precision for smooth blending
    cursor = np.zeros((large_size, large_size, 4), dtype=np.float32)
    
    # Simple clean arrow - just 3 points for smooth diagonal
    # Tip at top, left edge straight down, diagonal back to tip
    points = np.array([
        [large_size * 0.12, large_size * 0.02],   # Tip (top)
        [large_size * 0.12, large_size * 0.72],   # Bottom left
        [large_size * 0.52, large_size * 0.32],   # Right point (on diagonal)
    ], dtype=np.float32)
    
    points_int = points.astype(np.int32)
    
    # Draw soft shadow
    shadow_layer = np.zeros((large_size, large_size), dtype=np.float32)
    for i in range(8, 0, -1):
        offset = int(large_size * 0.005 * i)
        shadow_pts = (points + offset).astype(np.int32)
        temp = np.zeros((large_size, large_size), dtype=np.uint8)
        cv2.fillPoly(temp, [shadow_pts], 255)
        shadow_layer = np.maximum(shadow_layer, temp.astype(np.float32) * (0.06 - i * 0.006))
    
    # Blur shadow
    shadow_layer = cv2.GaussianBlur(shadow_layer, (31, 31), 0)
    cursor[:, :, 3] = np.maximum(cursor[:, :, 3], shadow_layer * 255)
    
    # Draw black outline on separate layer
    outline_layer = np.zeros((large_size, large_size), dtype=np.uint8)
    cv2.fillPoly(outline_layer, [points_int], 255)
    
    # Blur outline for antialiasing
    outline_aa = cv2.GaussianBlur(outline_layer.astype(np.float32), (9, 9), 0)
    
    # Apply black where outline exists
    mask = outline_aa > 0
    cursor[mask, 0] = 0
    cursor[mask, 1] = 0
    cursor[mask, 2] = 0
    cursor[:, :, 3] = np.maximum(cursor[:, :, 3], outline_aa)
    
    # White fill - inset from outline
    border = int(large_size * 0.025)
    inner_points = np.array([
        [large_size * 0.12 + border, large_size * 0.02 + border],
        [large_size * 0.12 + border, large_size * 0.66],
        [large_size * 0.46, large_size * 0.32],
    ], dtype=np.int32)
    
    white_layer = np.zeros((large_size, large_size), dtype=np.uint8)
    cv2.fillPoly(white_layer, [inner_points], 255)
    
    # Blur white for antialiasing
    white_aa = cv2.GaussianBlur(white_layer.astype(np.float32), (7, 7), 0)
    
    # Blend white over black
    white_mask = white_aa / 255.0
    cursor[:, :, 0] = cursor[:, :, 0] * (1 - white_mask) + 255 * white_mask
    cursor[:, :, 1] = cursor[:, :, 1] * (1 - white_mask) + 255 * white_mask
    cursor[:, :, 2] = cursor[:, :, 2] * (1 - white_mask) + 255 * white_mask
    
    # Convert to uint8
    cursor = np.clip(cursor, 0, 255).astype(np.uint8)
    
    # Scale down with high-quality interpolation
    cursor = cv2.resize(cursor, (size, size), interpolation=cv2.INTER_AREA)
    
    return cursor


def create_macos_cursor(size=48):
    """Create a macOS-style cursor."""
    scale = 4
    large_size = size * scale
    cursor = np.zeros((large_size, large_size, 4), dtype=np.uint8)
    
    # macOS arrow shape
    points = np.array([
        [int(large_size * 0.12), 0],
        [int(large_size * 0.12), int(large_size * 0.72)],
        [int(large_size * 0.28), int(large_size * 0.56)],
        [int(large_size * 0.45), int(large_size * 0.82)],
        [int(large_size * 0.55), int(large_size * 0.77)],
        [int(large_size * 0.38), int(large_size * 0.52)],
        [int(large_size * 0.58), int(large_size * 0.52)],
    ], dtype=np.int32)
    
    # Shadow
    for i in range(3, 0, -1):
        shadow_points = points + i * 2
        alpha = 30 + i * 15
        cv2.fillPoly(cursor, [shadow_points], (0, 0, 0, alpha))
    
    # Black outline
    cv2.fillPoly(cursor, [points], (0, 0, 0, 255))
    cv2.polylines(cursor, [points], True, (0, 0, 0, 255), int(large_size * 0.04))
    
    # White fill
    inner = (points - [int(large_size * 0.12), 0]) * 0.85 + [int(large_size * 0.14), int(large_size * 0.02)]
    inner = inner.astype(np.int32)
    cv2.fillPoly(cursor, [inner], (255, 255, 255, 255))
    
    # Scale down
    cursor = cv2.resize(cursor, (size, size), interpolation=cv2.INTER_AREA)
    
    return cursor


def create_dot_cursor(size=24, color=(255, 0, 0)):
    """Create a simple dot cursor."""
    cursor = np.zeros((size, size, 4), dtype=np.uint8)
    center = size // 2
    radius = size // 2 - 2
    
    cv2.circle(cursor, (center, center), radius, (*color, 255), -1)
    
    return cursor


def create_ring_cursor(size=40, color=(0, 255, 0), thickness=3):
    """Create a ring cursor (hollow circle)."""
    cursor = np.zeros((size, size, 4), dtype=np.uint8)
    center = size // 2
    radius = size // 2 - thickness
    
    cv2.circle(cursor, (center, center), radius, (*color, 255), thickness)
    
    return cursor


def create_crosshair_cursor(size=32, color=(255, 255, 255), thickness=2):
    """Create a crosshair cursor."""
    cursor = np.zeros((size, size, 4), dtype=np.uint8)
    center = size // 2
    
    # Horizontal line
    cv2.line(cursor, (0, center), (size, center), (*color, 255), thickness)
    # Vertical line
    cv2.line(cursor, (center, 0), (center, size), (*color, 255), thickness)
    # Center dot
    cv2.circle(cursor, (center, center), 3, (*color, 255), -1)
    
    return cursor


def overlay_cursor(frame, cursor_img, x, y):
    """Overlay cursor image on frame at position (x, y), centered."""
    h, w = cursor_img.shape[:2]
    
    # Convert to int and center cursor on position
    x = int(x) - w // 2
    y = int(y) - h // 2
    
    # Calculate bounds
    y1, y2 = max(0, y), min(frame.shape[0], y + h)
    x1, x2 = max(0, x), min(frame.shape[1], x + w)
    
    oy1 = max(0, -y)
    ox1 = max(0, -x)
    oy2 = oy1 + (y2 - y1)
    ox2 = ox1 + (x2 - x1)
    
    if y2 <= y1 or x2 <= x1:
        return frame
    
    result = frame.copy()
    
    # Alpha blending
    if cursor_img.shape[2] == 4:
        alpha = cursor_img[oy1:oy2, ox1:ox2, 3] / 255.0
        alpha = np.stack([alpha] * 3, axis=-1)
        
        cursor_rgb = cursor_img[oy1:oy2, ox1:ox2, :3]
        background = result[y1:y2, x1:x2]
        
        result[y1:y2, x1:x2] = (alpha * cursor_rgb + (1 - alpha) * background).astype(np.uint8)
    
    return result


def smooth_positions(positions, alpha=0.35):
    """
    Smooth cursor positions using bidirectional exponential moving average.
    Creates natural, fluid cursor movement.
    """
    if len(positions) < 2:
        return positions
    
    # Forward pass
    smoothed = [positions[0].copy()]
    for i in range(1, len(positions)):
        prev = smoothed[-1]
        curr = positions[i]
        
        new_x = alpha * curr['x'] + (1 - alpha) * prev['x']
        new_y = alpha * curr['y'] + (1 - alpha) * prev['y']
        
        smoothed.append({
            'frame': curr['frame'],
            'x': new_x,
            'y': new_y
        })
    
    # Backward pass for even smoother result
    for i in range(len(smoothed) - 2, -1, -1):
        next_pos = smoothed[i + 1]
        curr = smoothed[i]
        
        curr['x'] = alpha * curr['x'] + (1 - alpha) * next_pos['x']
        curr['y'] = alpha * curr['y'] + (1 - alpha) * next_pos['y']
    
    return smoothed


def process_video(input_path, output_path, cursor_log_path=None, cursor_type='circle',
                  cursor_size=32, cursor_color=(0, 255, 255), hide_original=True):
    """
    Process video and replace cursor using logged positions.
    """
    input_path = Path(input_path)
    output_path = Path(output_path)
    
    # Find cursor log
    if cursor_log_path is None:
        cursor_log_path = input_path.with_suffix('.json')
    else:
        cursor_log_path = Path(cursor_log_path)
    
    if not cursor_log_path.exists():
        print(f"Error: Cursor log not found: {cursor_log_path}")
        print("Make sure to record with record_with_cursor.py first.")
        return
    
    # Load cursor positions
    print(f"Loading cursor positions from {cursor_log_path}...")
    with open(cursor_log_path, 'r') as f:
        cursor_data = json.load(f)
    
    positions = cursor_data['positions']
    print(f"  Loaded {len(positions)} cursor positions")
    
    # Smooth positions for natural movement
    print("Smoothing cursor movement...")
    positions = smooth_positions(positions)
    
    # Create cursor image
    if cursor_type == 'circle':
        cursor_img = create_circle_cursor(cursor_size, cursor_color)
    elif cursor_type == 'dot':
        cursor_img = create_dot_cursor(cursor_size, cursor_color)
    elif cursor_type == 'ring':
        cursor_img = create_ring_cursor(cursor_size, cursor_color)
    elif cursor_type == 'crosshair':
        cursor_img = create_crosshair_cursor(cursor_size, cursor_color)
    elif cursor_type == 'fancy':
        cursor_img = create_fancy_cursor(cursor_size)
    elif cursor_type == 'macos':
        cursor_img = create_macos_cursor(cursor_size)
    else:
        cursor_img = create_fancy_cursor(cursor_size)
    
    # Open video
    cap = cv2.VideoCapture(str(input_path))
    if not cap.isOpened():
        print(f"Error: Could not open video: {input_path}")
        return
    
    fps = int(cap.get(cv2.CAP_PROP_FPS))
    width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
    total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))

    print(f"Video: {width}x{height} @ {fps}fps")

    # Create position lookup by frame
    pos_by_frame = {p['frame']: (p['x'], p['y']) for p in positions}

    # Process frames
    print("Processing frames...")
    temp_dir = tempfile.mkdtemp()

    frame_idx = 0
    while True:
        ret, frame = cap.read()
        if not ret:
            break

        # Get cursor position for this frame
        if frame_idx in pos_by_frame:
            x, y = pos_by_frame[frame_idx]

            # Overlay new cursor
            frame = overlay_cursor(frame, cursor_img, x, y)

        # Save frame
        frame_path = os.path.join(temp_dir, f"frame_{frame_idx:06d}.png")
        cv2.imwrite(frame_path, frame)

        frame_idx += 1
        if frame_idx % 100 == 0:
            print(f"  Processed {frame_idx}/{total_frames} frames")
    
    cap.release()
    
    # Encode with ffmpeg
    print("Encoding video...")
    out_width = width if width % 2 == 0 else width - 1
    out_height = height if height % 2 == 0 else height - 1
    
    ffmpeg_cmd = [
        'ffmpeg', '-y',
        '-framerate', str(fps),
        '-i', os.path.join(temp_dir, 'frame_%06d.png'),
        '-vf', f'scale={out_width}:{out_height}',
        '-c:v', 'libx264',
        '-preset', 'medium',
        '-crf', '23',
        '-pix_fmt', 'yuv420p',
        str(output_path)
    ]
    
    subprocess.run(ffmpeg_cmd, check=True, capture_output=True)
    
    # Cleanup
    print("Cleaning up...")
    for f in os.listdir(temp_dir):
        os.remove(os.path.join(temp_dir, f))
    os.rmdir(temp_dir)
    
    print(f"Done! Output saved to: {output_path}")


def main():
    parser = argparse.ArgumentParser(description="Replace cursor using logged positions")
    parser.add_argument("-i", "--input", required=True, help="Input video file")
    parser.add_argument("-o", "--output", required=True, help="Output video file")
    parser.add_argument("-l", "--log", help="Cursor log JSON file (default: same name as input)")
    parser.add_argument("--type", choices=['circle', 'dot', 'ring', 'crosshair', 'fancy', 'macos'], 
                        default='fancy', help="Cursor type (fancy and macos are beautiful arrow cursors)")
    parser.add_argument("--size", type=int, default=32, help="Cursor size in pixels")
    parser.add_argument("--color", default="yellow", 
                        help="Cursor color: red, green, blue, yellow, cyan, magenta, white")
    
    args = parser.parse_args()
    
    # Parse color
    colors = {
        'red': (0, 0, 255),
        'green': (0, 255, 0),
        'blue': (255, 0, 0),
        'yellow': (0, 255, 255),
        'cyan': (255, 255, 0),
        'magenta': (255, 0, 255),
        'white': (255, 255, 255),
        'orange': (0, 165, 255),
    }
    color = colors.get(args.color.lower(), (0, 255, 255))
    
    process_video(
        input_path=args.input,
        output_path=args.output,
        cursor_log_path=args.log,
        cursor_type=args.type,
        cursor_size=args.size,
        cursor_color=color
    )


if __name__ == "__main__":
    main()
